---
import { getCollection } from 'astro:content';

// 모든 블로그 글 가져오기
const allPosts = await getCollection('blog');

// 현재 선택된 태그 및 카테고리 확인 (여러 태그 지원)
const tagParams = Astro.url.searchParams.getAll('tag');
const currentTags = tagParams.length > 0 ? tagParams : [];
const currentCategory = Astro.url.searchParams.get('category');

// 태그 개수 계산
const tagCountMap = new Map<string, number>();
allPosts.forEach((post) => {
	const tags = post.data.tags || [];
	tags.forEach((tag) => {
		const currentCount = tagCountMap.get(tag) || 0;
		tagCountMap.set(tag, currentCount + 1);
	});
});

// 태그 배열로 변환하고 개수 순으로 정렬
const tags = Array.from(tagCountMap.entries())
	.map(([name, count]) => ({ name, count }))
	.sort((a, b) => b.count - a.count);

// 태그 크기 계산 (최소 0.8em, 최대 1.5em)
const maxCount = tags.length > 0 ? tags[0].count : 1;
const minCount = tags.length > 0 ? tags[tags.length - 1].count : 1;
const countRange = maxCount - minCount || 1;
---

<div class="tag-cloud">
	<h2>Tags</h2>
	<div class="tag-cloud-container">
		<a 
			href={currentCategory ? `/blog?category=${encodeURIComponent(currentCategory)}` : "/blog"}
			class={`tag-cloud-item all-tag ${currentTags.length === 0 ? 'active' : ''}`}
			data-tag-name=""
		>
			전체
		</a>
		{
			tags.length > 0 ? (
				tags.map((tag) => {
					const size = 0.8 + ((tag.count - minCount) / countRange) * 0.7;
					// 카테고리 필터가 있으면 함께 유지
					const tagUrl = currentCategory 
						? `/blog?category=${encodeURIComponent(currentCategory)}&tag=${encodeURIComponent(tag.name)}`
						: `/blog?tag=${encodeURIComponent(tag.name)}`;
					const isActive = currentTags.includes(tag.name);
					return (
						<a 
							href={tagUrl}
							class={`tag-cloud-item ${isActive ? 'active' : ''}`}
							style={`font-size: ${size}em;`}
							data-count={tag.count}
							data-tag-name={tag.name}
						>
							{tag.name}
						</a>
					);
				})
			) : (
				<span class="no-tags">태그가 없습니다</span>
			)
		}
	</div>
</div>

<style>
	.tag-cloud {
		background-color: rgba(26, 26, 46, 0.8);
		padding: 1.5em;
		border: 3px solid #00ff41;
		box-shadow: 4px 4px 0 0 #00ff41;
		box-sizing: border-box;
		width: 100%;
		position: relative;
		z-index: 1;
		pointer-events: auto;
	}

	.tag-cloud h2 {
		font-family: 'Pretendard', 'Courier New', monospace;
		font-size: 1.25em;
		margin: 0 0 1em 0;
		color: #00ff41;
		border-bottom: 2px solid #00ff41;
		padding-bottom: 0.5em;
		text-shadow: 2px 2px 0 #16213e;
		letter-spacing: 0.1em;
	}

	.tag-cloud-container {
		display: flex;
		flex-wrap: wrap;
		gap: 0.75em;
		align-items: center;
		justify-content: flex-start;
		position: relative;
		z-index: 10;
		pointer-events: auto;
	}

	.tag-cloud-item {
		display: inline-block;
		padding: 0.4em 0.8em;
		background: rgba(0, 255, 65, 0.1);
		border: 2px solid #00ff41;
		border-radius: 4px;
		color: #00ff41;
		text-decoration: none;
		font-family: 'Pretendard', 'Courier New', monospace;
		font-weight: 600;
		transition: all 0.2s ease;
		box-shadow: 2px 2px 0 0 rgba(0, 255, 65, 0.2);
		white-space: nowrap;
		line-height: 1.4;
		position: relative;
		z-index: 10;
		cursor: pointer;
		pointer-events: auto !important;
		user-select: none;
	}

	.tag-cloud-item:hover {
		background: rgba(0, 255, 65, 0.2);
		border-color: #ffd700;
		color: #ffd700;
		transform: translate(-1px, -1px);
		box-shadow: 3px 3px 0 0 rgba(255, 215, 0, 0.3);
	}

	.tag-cloud-item[data-count="1"] {
		opacity: 0.7;
	}

	.tag-cloud-item.all-tag {
		font-size: 1.1em;
		font-weight: 700;
		background: rgba(255, 215, 0, 0.1);
		border-color: #ffd700;
		color: #ffd700;
	}

	.tag-cloud-item.all-tag:hover {
		background: rgba(255, 215, 0, 0.2);
	}

	.tag-cloud-item.active {
		background: rgba(255, 215, 0, 0.25) !important;
		border-color: #ffd700 !important;
		color: #ffd700 !important;
		box-shadow: 3px 3px 0 0 rgba(255, 215, 0, 0.5) !important;
		font-weight: 700 !important;
		transform: scale(1.05);
	}

	.tag-cloud-item.all-tag.active {
		background: rgba(255, 215, 0, 0.3) !important;
		border-color: #ffd700 !important;
		color: #ffd700 !important;
		box-shadow: 3px 3px 0 0 rgba(255, 215, 0, 0.6) !important;
		font-weight: 700 !important;
		transform: scale(1.05);
	}

	.tag-cloud-item.active:hover {
		background: rgba(255, 215, 0, 0.35) !important;
		border-color: #ffeb3b !important;
		color: #ffeb3b !important;
		box-shadow: 4px 4px 0 0 rgba(255, 215, 0, 0.6) !important;
		transform: scale(1.08) translate(-1px, -1px);
	}

	.tag-cloud-item.all-tag.active:hover {
		background: rgba(255, 215, 0, 0.4) !important;
		border-color: #ffeb3b !important;
		color: #ffeb3b !important;
		box-shadow: 4px 4px 0 0 rgba(255, 215, 0, 0.7) !important;
		transform: scale(1.08) translate(-1px, -1px);
	}

	.no-tags {
		color: rgb(var(--gray));
		font-size: 0.9em;
		font-family: 'Pretendard', 'Courier New', monospace;
	}

	/* 모바일 반응형 */
	@media (max-width: 1279px) {
		.tag-cloud {
			border: 1px solid rgba(0, 255, 65, 0.3);
		}
	}
</style>

<script>
	// 태그 클라우드 클라이언트 사이드 필터링
	document.addEventListener('DOMContentLoaded', () => {
		// 태그 링크는 동적으로 다시 선택하도록 함수로 분리
		function getTagLinks() {
			return document.querySelectorAll('.tag-cloud-item');
		}
		
		const blogCards = document.querySelectorAll('.blog-card');
		const categoryFilterInfo = document.querySelector('.category-filter-info');
		const filterTitle = document.querySelector('.filter-title');
		const clearFilterLink = document.querySelector('.clear-filter');
		
		// 현재 URL 파라미터 가져오기 (여러 태그 지원)
		function getCurrentParams() {
			const urlParams = new URLSearchParams(window.location.search);
			return {
				category: urlParams.get('category'),
				tags: urlParams.getAll('tag')
			};
		}
		
		// active 상태 업데이트 함수
		function updateActiveStates(selectedTagsOverride?: string[]) {
			const params = getCurrentParams();
			const currentTagLinks = getTagLinks();
			const selectedTags = selectedTagsOverride || params.tags;
			
			// 먼저 모든 태그의 active 클래스 제거
			currentTagLinks.forEach((link) => {
				link.classList.remove('active');
			});
			
			// requestAnimationFrame으로 다음 프레임에 active 상태 적용
			requestAnimationFrame(() => {
				currentTagLinks.forEach((link) => {
					const linkTag = link.getAttribute('data-tag-name');
					
					if (link.classList.contains('all-tag')) {
						// 전체 태그는 선택된 태그가 없을 때만 active
						// 다른 태그가 선택되면 항상 active 제거
						if (selectedTags.length === 0) {
							link.classList.add('active');
						} else {
							// 다른 태그가 선택되었으면 확실히 active 제거
							link.classList.remove('active');
						}
					} else {
						// 일반 태그는 selectedTags에 포함되어 있으면 active
						if (linkTag) {
							const normalizedLinkTag = linkTag.trim();
							const isSelected = selectedTags.some(tag => tag.trim() === normalizedLinkTag);
							if (isSelected) {
								link.classList.add('active');
							} else {
								link.classList.remove('active');
							}
						}
					}
					// 강제 리플로우
					void link.offsetHeight;
				});
			});
		}
		
		function toggleTag(tagName: string | null, clickedLink?: HTMLElement) {
			const params = getCurrentParams();
			const currentCategory = params.category;
			let selectedTags = [...params.tags];
			
			// 전체 태그 클릭 시 모든 태그 제거
			if (!tagName) {
				selectedTags = [];
			} else {
				// 태그 토글 (이미 선택되어 있으면 제거, 없으면 추가)
				// 정확한 문자열 비교를 위해 trim() 사용
				const normalizedTagName = tagName.trim();
				const tagIndex = selectedTags.findIndex(tag => tag.trim() === normalizedTagName);
				if (tagIndex > -1) {
					selectedTags.splice(tagIndex, 1);
				} else {
					selectedTags.push(normalizedTagName);
				}
				
				// 다른 태그가 선택되면 전체 태그의 active 상태 확실히 제거
				if (selectedTags.length > 0) {
					const allTagLink = document.querySelector('.tag-cloud-item.all-tag');
					if (allTagLink) {
						allTagLink.classList.remove('active');
					}
				}
			}
			
			// URL 업데이트 (페이지 리로드 없이)
			const newParams = new URLSearchParams();
			if (currentCategory) {
				newParams.set('category', currentCategory);
			}
			selectedTags.forEach(tag => {
				newParams.append('tag', tag);
			});
			const newUrl = newParams.toString() 
				? `/blog?${newParams.toString()}` 
				: '/blog';
			window.history.pushState({}, '', newUrl);
			
			// 글 목록 필터링 (카테고리와 태그 모두 고려)
			blogCards.forEach((card) => {
				const cardTags = (card.getAttribute('data-tags') || '').split(',').map(t => t.trim()).filter(t => t);
				const cardCategory = card.getAttribute('data-category') || '';
				
				let shouldShow = true;
				
				// 카테고리 필터링
				if (currentCategory && cardCategory !== currentCategory) {
					shouldShow = false;
				}
				
				// 태그 필터링 (선택된 모든 태그를 가진 글만 표시)
				if (shouldShow && selectedTags.length > 0) {
					const hasAllTags = selectedTags.every(selectedTag => cardTags.includes(selectedTag));
					if (!hasAllTags) {
						shouldShow = false;
					}
				}
				
				(card as HTMLElement).style.display = shouldShow ? '' : 'none';
			});
			
			// 필터 정보 표시/숨김
			if (selectedTags.length > 0 || currentCategory) {
				if (categoryFilterInfo) {
					(categoryFilterInfo as HTMLElement).style.display = 'flex';
					if (filterTitle) {
						const parts = [];
						if (currentCategory) parts.push(`Category: ${currentCategory}`);
						if (selectedTags.length > 0) {
							parts.push(`Tags: ${selectedTags.join(', ')}`);
						}
						filterTitle.textContent = parts.join(' | ');
					}
				}
			} else {
				if (categoryFilterInfo) {
					(categoryFilterInfo as HTMLElement).style.display = 'none';
				}
			}
			
			// active 상태 업데이트 (선택된 태그 전달)
			updateActiveStates(selectedTags);
			
			// 필터 정보 업데이트
			if (selectedTags.length > 0 || currentCategory) {
				if (categoryFilterInfo) {
					(categoryFilterInfo as HTMLElement).style.display = 'flex';
					if (filterTitle) {
						const parts = [];
						if (currentCategory) parts.push(`Category: ${currentCategory}`);
						if (selectedTags.length > 0) parts.push(`Tags: ${selectedTags.join(', ')}`);
						filterTitle.textContent = parts.join(' | ');
					}
				}
			} else {
				if (categoryFilterInfo) {
					(categoryFilterInfo as HTMLElement).style.display = 'none';
				}
			}
			
			// 카테고리 사이드바에 변경 알림
			window.dispatchEvent(new CustomEvent('tagFilterChanged'));
		}
		
		// 태그 링크 클릭 이벤트 (이벤트 위임 사용)
		const tagCloudContainer = document.querySelector('.tag-cloud-container');
		if (tagCloudContainer) {
			tagCloudContainer.addEventListener('click', (e) => {
				const target = e.target as HTMLElement;
				const link = target.closest('.tag-cloud-item') as HTMLAnchorElement;
				if (!link) return;
				
				e.preventDefault();
				const href = link.getAttribute('href');
				if (!href) return;
				
				// URL에서 태그 추출
				const url = new URL(href, window.location.origin);
				const tagParam = url.searchParams.get('tag');
				// 클릭한 링크를 전달하여 태그 토글
				toggleTag(tagParam, link);
			});
		}
		
		// Clear Filter 링크는 blog/index.astro에서 처리
		
		// 초기 필터링 및 active 상태 설정
		function applyFilters() {
			const params = getCurrentParams();
			const selectedTags = params.tags;
			const currentCategory = params.category;
			
			// 카테고리와 태그 모두 고려하여 필터링
			blogCards.forEach((card) => {
				const cardTags = (card.getAttribute('data-tags') || '').split(',').map(t => t.trim()).filter(t => t);
				const cardCategory = card.getAttribute('data-category') || '';
				
				let shouldShow = true;
				
				// 카테고리 필터링
				if (currentCategory && cardCategory !== currentCategory) {
					shouldShow = false;
				}
				
				// 태그 필터링 (선택된 모든 태그를 가진 글만 표시)
				if (shouldShow && selectedTags.length > 0) {
					const hasAllTags = selectedTags.every(selectedTag => cardTags.includes(selectedTag.trim()));
					if (!hasAllTags) {
						shouldShow = false;
					}
				}
				
				(card as HTMLElement).style.display = shouldShow ? '' : 'none';
			});
			
			// 필터 정보 표시/숨김
			if (selectedTags.length > 0 || currentCategory) {
				if (categoryFilterInfo) {
					(categoryFilterInfo as HTMLElement).style.display = 'flex';
					if (filterTitle) {
						const parts = [];
						if (currentCategory) parts.push(`Category: ${currentCategory}`);
						if (selectedTags.length > 0) parts.push(`Tags: ${selectedTags.join(', ')}`);
						filterTitle.textContent = parts.join(' | ');
					}
				}
			} else {
				if (categoryFilterInfo) {
					(categoryFilterInfo as HTMLElement).style.display = 'none';
				}
			}
		}
		
		// 초기 필터링 실행
		applyFilters();
		
		// 초기 active 상태 설정 (약간의 지연 후 실행)
		setTimeout(() => {
			updateActiveStates();
		}, 0);
		
		// 카테고리 변경 감지 (popstate 이벤트)
		window.addEventListener('popstate', () => {
			applyFilters();
			updateActiveStates();
		});
		
		// 커스텀 이벤트로 카테고리 변경 감지
		window.addEventListener('categoryFilterChanged', () => {
			applyFilters();
			updateActiveStates();
		});
	});
</script>
