---
import { getCollection } from 'astro:content';
import { buildBlogUrl } from '../utils/filter';

// 모든 블로그 글 가져오기
const allPosts = await getCollection('blog');

// 현재 선택된 카테고리 및 태그 확인 (여러 태그 지원)
const currentCategory = Astro.url.searchParams.get('category');
const currentTags = Astro.url.searchParams.getAll('tag');

// 카테고리 개수 계산
const categoryCountMap = new Map<string, number>();
allPosts.forEach((post) => {
	const category = post.data.category;
	if (category) {
		const currentCount = categoryCountMap.get(category) || 0;
		categoryCountMap.set(category, currentCount + 1);
	}
});

// 카테고리 배열로 변환하고 개수 순으로 정렬
const categories = Array.from(categoryCountMap.entries())
	.map(([name, count]) => ({ name, count }))
	.sort((a, b) => b.count - a.count);
---

<div class="category-sidebar">
	<h2>Categories</h2>
	<ul class="category-list">
		{
			categories.length > 0 ? (
				categories.map((category) => {
					const categoryUrl = buildBlogUrl(category.name, currentTags);
					return (
						<li class="category-item">
							<a 
								href={categoryUrl}
								class={currentCategory === category.name ? 'active' : ''}
								data-category-name={category.name}
							>
								<span class="category-name">{category.name}</span>
								<span class="category-count">({category.count})</span>
							</a>
						</li>
					);
				})
			) : (
				<li class="category-item">
					<span class="no-categories">카테고리가 없습니다</span>
				</li>
			)
		}
	</ul>
</div>

<style>
	.category-sidebar {
		background-color: var(--color-bg-card);
		padding: var(--spacing-md);
		border: var(--border-width-thin) solid var(--color-primary);
		border-radius: var(--border-radius);
		box-shadow: 0 0 10px var(--color-nebula-green);
		box-sizing: border-box;
		width: 100%;
	}

	.category-sidebar h2 {
		font-family: var(--font-family-mono);
		font-size: 1.25em;
		margin: 0 0 var(--spacing-sm) 0;
		color: var(--color-primary);
		border-bottom: var(--border-width-medium) solid var(--color-primary);
		padding-bottom: var(--spacing-xs);
		text-shadow: var(--shadow-offset-sm) var(--shadow-offset-sm) 0 var(--color-shadow-dark);
		letter-spacing: 0.1em;
	}

	.category-list {
		list-style: none;
		padding: 0;
		margin: 0;
	}

	.category-item {
		margin-bottom: 0.5em;
	}

	.category-item a {
		display: flex;
		justify-content: space-between;
		align-items: center;
		padding: 0.5em 0.8em;
		border-radius: 2px;
		text-decoration: none;
		color: #e5e9f0;
		font-family: 'Pretendard', 'Courier New', monospace;
		transition: all 0.2s ease;
		border: 1px solid transparent;
		position: relative;
	}

	.category-item a:hover {
		background-color: var(--color-nebula-green);
		border-color: var(--color-primary);
		color: var(--color-secondary);
		transform: translateX(4px);
		box-shadow: var(--shadow-offset-sm) var(--shadow-offset-sm) 0 0 var(--color-nebula-green-medium);
	}

	.category-name {
		font-weight: 700;
	}

	.category-count {
		color: var(--color-primary);
		font-size: 0.9em;
		margin-left: var(--spacing-xs);
	}
	
	.category-item a:hover .category-count {
		color: var(--color-secondary);
	}

	.category-item a.active {
		background-color: var(--color-nebula-green-light);
		border-color: var(--color-primary);
		color: var(--color-primary);
		box-shadow: var(--shadow-offset-sm) var(--shadow-offset-sm) 0 0 var(--color-nebula-green-strong);
	}

	.category-item a.active .category-count {
		color: var(--color-primary);
	}

	.category-item a.active:hover {
		background-color: var(--color-nebula-green-medium);
		border-color: var(--color-secondary);
		color: var(--color-secondary);
	}

	.no-categories {
		color: rgb(var(--gray));
		font-size: 0.9em;
		font-family: var(--font-family-mono);
	}

	/* 모바일 반응형 */
	@media (max-width: 1279px) {
		.category-sidebar {
			position: static;
			max-height: none;
			margin-bottom: var(--spacing-lg);
			border: var(--border-width-thin) solid var(--color-nebula-green-strong);
		}
		
		.category-list {
			display: flex;
			flex-wrap: wrap;
			gap: var(--spacing-xs);
		}

		.category-item {
			margin-bottom: 0;
		}
		
		.category-item a {
			border: var(--border-width-thin) solid var(--color-nebula-green-strong);
		}
	}
</style>

<script>
	// 카테고리 사이드바 클라이언트 사이드 필터링
	document.addEventListener('DOMContentLoaded', () => {
		const categoryLinks = document.querySelectorAll('.category-item a');
		const blogCards = document.querySelectorAll('.blog-card');
		const categoryFilterInfo = document.querySelector('.category-filter-info');
		const filterTitle = document.querySelector('.filter-title');
		const clearFilterLink = document.querySelector('.clear-filter');
		
		// 현재 URL 파라미터 가져오기 (여러 태그 지원)
		function getCurrentParams() {
			const urlParams = new URLSearchParams(window.location.search);
			return {
				category: urlParams.get('category'),
				tags: urlParams.getAll('tag')
			};
		}
		
		function filterByCategory(categoryName: string | null) {
			const params = getCurrentParams();
			const currentTags = params.tags;
			
			// URL 업데이트 (페이지 리로드 없이, 여러 태그 지원)
			const newParams = new URLSearchParams();
			if (categoryName) {
				newParams.set('category', categoryName);
			}
			currentTags.forEach(tag => {
				newParams.append('tag', tag);
			});
			const newUrl = newParams.toString() 
				? `/blog?${newParams.toString()}` 
				: '/blog';
			window.history.pushState({}, '', newUrl);
			
			// 글 목록 필터링 (카테고리와 태그 모두 고려)
			blogCards.forEach((card) => {
				const cardTags = (card.getAttribute('data-tags') || '').split(',').map(t => t.trim()).filter(t => t);
				const cardCategory = card.getAttribute('data-category') || '';
				
				let shouldShow = true;
				
				// 카테고리 필터링
				if (categoryName && cardCategory !== categoryName) {
					shouldShow = false;
				}
				
				// 태그 필터링 (선택된 모든 태그를 가진 글만 표시)
				if (shouldShow && currentTags.length > 0) {
					const hasAllTags = currentTags.every(selectedTag => cardTags.includes(selectedTag.trim()));
					if (!hasAllTags) {
						shouldShow = false;
					}
				}
				
				(card as HTMLElement).style.display = shouldShow ? '' : 'none';
			});
			
			// 필터 정보 표시/숨김
			if (categoryName || currentTags.length > 0) {
				if (categoryFilterInfo) {
					(categoryFilterInfo as HTMLElement).style.display = 'flex';
					if (filterTitle) {
						const parts = [];
						if (categoryName) parts.push(`Category: ${categoryName}`);
						if (currentTags.length > 0) parts.push(`Tags: ${currentTags.join(', ')}`);
						filterTitle.textContent = parts.join(' | ');
					}
				}
			} else {
				if (categoryFilterInfo) {
					(categoryFilterInfo as HTMLElement).style.display = 'none';
				}
			}
			
			// active 상태 업데이트
			categoryLinks.forEach((link) => {
				const linkCategory = link.getAttribute('data-category-name');
				if (linkCategory === categoryName) {
					link.classList.add('active');
				} else {
					link.classList.remove('active');
				}
			});
			
			// 태그 클라우드에 변경 알림
			window.dispatchEvent(new CustomEvent('categoryFilterChanged'));
		}
		
		// 카테고리 링크 클릭 이벤트
		categoryLinks.forEach((link) => {
			link.addEventListener('click', (e) => {
				e.preventDefault();
				const href = link.getAttribute('href');
				if (!href) return;
				
				// URL에서 카테고리 추출
				const url = new URL(href, window.location.origin);
				const categoryParam = url.searchParams.get('category');
				filterByCategory(categoryParam);
			});
		});
		
		// Clear Filter 링크는 blog/index.astro에서 처리
		
		// 초기 필터링 (URL 파라미터에 카테고리나 태그가 있으면)
		const params = getCurrentParams();
		if (params.category || params.tags.length > 0) {
			if (params.category) {
				filterByCategory(params.category);
			} else {
				// 카테고리는 없지만 태그가 있으면 필터링만 적용
				const blogCards = document.querySelectorAll('.blog-card');
				const categoryFilterInfo = document.querySelector('.category-filter-info');
				const filterTitle = document.querySelector('.filter-title');
				const currentTags = params.tags;
				
				blogCards.forEach((card) => {
					const cardTags = (card.getAttribute('data-tags') || '').split(',').map(t => t.trim()).filter(t => t);
					
					if (currentTags.length > 0) {
						const hasAllTags = currentTags.every(selectedTag => cardTags.includes(selectedTag.trim()));
						(card as HTMLElement).style.display = hasAllTags ? '' : 'none';
					}
				});
				
				if (currentTags.length > 0 && categoryFilterInfo) {
					(categoryFilterInfo as HTMLElement).style.display = 'flex';
					if (filterTitle) {
						filterTitle.textContent = `Tags: ${currentTags.join(', ')}`;
					}
				}
			}
		}
		
		// 태그 변경 감지 (popstate 이벤트)
		window.addEventListener('popstate', () => {
			const params = getCurrentParams();
			if (params.category) {
				filterByCategory(params.category);
			} else if (params.tags.length > 0) {
				// 카테고리는 없지만 태그가 있으면 필터링만 적용
				const blogCards = document.querySelectorAll('.blog-card');
				const categoryFilterInfo = document.querySelector('.category-filter-info');
				const filterTitle = document.querySelector('.filter-title');
				const currentTags = params.tags;
				
				blogCards.forEach((card) => {
					const cardTags = (card.getAttribute('data-tags') || '').split(',').map(t => t.trim()).filter(t => t);
					
					if (currentTags.length > 0) {
						const hasAllTags = currentTags.every(selectedTag => cardTags.includes(selectedTag.trim()));
						(card as HTMLElement).style.display = hasAllTags ? '' : 'none';
					} else {
						(card as HTMLElement).style.display = '';
					}
				});
				
				if (currentTags.length > 0 && categoryFilterInfo) {
					(categoryFilterInfo as HTMLElement).style.display = 'flex';
					if (filterTitle) {
						filterTitle.textContent = `Tags: ${currentTags.join(', ')}`;
					}
				} else if (categoryFilterInfo) {
					(categoryFilterInfo as HTMLElement).style.display = 'none';
				}
			} else {
				filterByCategory(null);
			}
		});
		
		// 커스텀 이벤트로 태그 변경 감지
		window.addEventListener('tagFilterChanged', () => {
			const params = getCurrentParams();
			if (params.category) {
				filterByCategory(params.category);
			} else if (params.tags.length > 0) {
				// 카테고리는 없지만 태그가 있으면 필터링만 적용
				const blogCards = document.querySelectorAll('.blog-card');
				const categoryFilterInfo = document.querySelector('.category-filter-info');
				const filterTitle = document.querySelector('.filter-title');
				const currentTags = params.tags;
				
				blogCards.forEach((card) => {
					const cardTags = (card.getAttribute('data-tags') || '').split(',').map(t => t.trim()).filter(t => t);
					
					if (currentTags.length > 0) {
						const hasAllTags = currentTags.every(selectedTag => cardTags.includes(selectedTag.trim()));
						(card as HTMLElement).style.display = hasAllTags ? '' : 'none';
					}
				});
				
				if (currentTags.length > 0 && categoryFilterInfo) {
					(categoryFilterInfo as HTMLElement).style.display = 'flex';
					if (filterTitle) {
						filterTitle.textContent = `Tags: ${currentTags.join(', ')}`;
					}
				}
			}
		});
	});
</script>
